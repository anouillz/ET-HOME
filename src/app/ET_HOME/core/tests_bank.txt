from django.test import Client as DjangoClient, RequestFactory, TestCase
from unittest.mock import patch, MagicMock
from bank.models import Transaction, SpendingCategory
from ET_HOME.core.bank_auth import generate_secret, generate_token, sync_account, sync_transactions
from bank.models import Client as BankClient, Secret, Token, BankAccount
from django.utils.timezone import now
from ET_HOME.models import BankAccount as AppBankAccount
from datetime import timedelta
import uuid
import secrets


class BankIntegrationTests(TestCase):
    databases = {"default", "db_bank"}  # Ensure test allows queries to both databases

    def setUp(self):
        """Set up a test user and bank account"""
        self.client = DjangoClient()
        self.user = BankClient.objects.create_user(username="testuser", password="testpass")

        # Create a bank account using the bank.models.BankAccount model
        self.bank_account = BankAccount.objects.create(
            user=self.user,
            account_number="12345678",
            bank_name="Test Bank",
            balance=1000.00
        )

        # Create a secret using bank.models.Secret with a valid 64-character hex string
        self.secret = Secret.objects.create(
            account=self.bank_account,
            code=secrets.token_hex(32)
        )

        # Create a token with an expiration time one hour from now
        self.token = Token.objects.create(
            id=uuid.uuid4(),
            code="test_token_code",
            account=self.bank_account,
            secret=self.secret,
            created_at=now(),
            expires_at=now() + timedelta(hours=1),
            activated=True,
            challenge="test_challenge"
        )

    @patch("ET_HOME.core.bank_auth.requests.post")
    def test_generate_secret_success(self, mock_post):
        """Test successful secret generation"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"status": "success", "secret_id": str(self.secret.id)}
        mock_post.return_value = mock_response

        # Create a fake request using RequestFactory
        factory = RequestFactory()
        request = factory.post("/")
        response = generate_secret(request, "12345678", "testpassword")
        self.assertIsNotNone(response)
        self.assertEqual(response["secret_id"], str(self.secret.id))

    @patch("ET_HOME.core.bank_auth.requests.post")
    def test_generate_token_success(self, mock_post):
        """Test successful token generation"""
        factory = RequestFactory()
        request = factory.post("/")

        mock_response_challenge = MagicMock()
        mock_response_challenge.status_code = 200
        mock_response_challenge.json.return_value = {
            "status": "success",
            "challenge": "abcdef1234567890abcdef1234567890",
            "token_id": str(uuid.uuid4())
        }

        mock_response_validation = MagicMock()
        mock_response_validation.status_code = 200
        mock_response_validation.json.return_value = {
            "status": "success",
            "token": {
                "id": str(uuid.uuid4()),
                "code": "test_token_code",
                "expires_at": str(now() + timedelta(hours=1))
            }
        }

        # The first POST call returns the challenge; the second validates and returns the token.
        mock_post.side_effect = [mock_response_challenge, mock_response_validation]

        token, err = generate_token(request, "12345678", self.secret.code, str(self.secret.id))
        self.assertIsNone(err)
        self.assertIsNotNone(token)
        self.assertEqual(token["code"], "test_token_code")

    @patch("ET_HOME.core.bank_auth.requests.get")
    def test_sync_account_success(self, mock_get):
        """Test successful bank account sync"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "status": "success",
            "data": {
                "balance": 2000.00,
                "account_number": "12345678",
                "bank_name": "Test Bank"
            }
        }
        mock_get.return_value = mock_response

        factory = RequestFactory()
        request = factory.get("/")
        sync_result = sync_account(request, self.bank_account)
        self.assertTrue(sync_result)

        # Verify that the bank account balance has been updated in the database.
        self.bank_account.refresh_from_db()
        self.assertEqual(self.bank_account.balance, 2000.00)

    @patch("ET_HOME.core.bank_auth.requests.get")
    def test_sync_transactions_success(self, mock_get):
        """Test transaction synchronization"""
        # Ensure the spending category exists.
        SpendingCategory.objects.create(name="Food")

        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "status": "success",
            "data": [
                {
                    "id": str(uuid.uuid4()),
                    "amount": 50.00,
                    "category": "Food",
                    "date": str(now()),
                    "description": "Restaurant"
                }
            ]
        }
        mock_get.return_value = mock_response

        factory = RequestFactory()
        request = factory.get("/")
        sync_result = sync_transactions(request, self.bank_account)
        self.assertTrue(sync_result)

        # Verify the transaction has been created and linked to the correct spending category.
        transaction = Transaction.objects.get(description="Restaurant")
        self.assertEqual(transaction.amount, 50.00)
        self.assertEqual(transaction.category.name, "Food")

    @patch("ET_HOME.core.bank_auth.requests.get")
    def test_sync_transactions_no_transactions(self, mock_get):
        """Test transaction sync when there are no transactions"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"status": "success", "data": []}
        mock_get.return_value = mock_response

        factory = RequestFactory()
        request = factory.get("/")
        sync_result = sync_transactions(request, self.bank_account)
        self.assertTrue(sync_result)  # Should still succeed even with no data.

        self.assertEqual(Transaction.objects.count(), 0)

    @patch("ET_HOME.core.bank_auth.requests.get")
    def test_sync_account_fail(self, mock_get):
        """Test failed account sync"""
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_response.json.return_value = {"status": "error", "message": "Invalid request"}
        mock_get.return_value = mock_response

        factory = RequestFactory()
        request = factory.get("/")
        sync_result = sync_account(request, self.bank_account)
        self.assertFalse(sync_result)  # Sync should fail.

    @patch("ET_HOME.core.bank_auth.requests.get")
    def test_get_req_no_valid_token(self, mock_get):
        """Test GET request without a valid (expired) token"""
        # Simulate an expired token.
        self.token.expires_at = now() - timedelta(seconds=10)
        self.token.save()

        mock_response = MagicMock()
        mock_response.status_code = 403
        mock_response.json.return_value = {"status": "error", "message": "Invalid token"}
        mock_get.return_value = mock_response

        factory = RequestFactory()
        request = factory.get("/")
        sync_result = sync_account(request, self.bank_account)
        self.assertFalse(sync_result)  # Should fail due to expired token.
